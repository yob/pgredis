## strings
conn.mget(keys)
conn.mset(*mset_args)
conn.get("stat:failed")
conn.incrby("stat:failed", fails)

## keys

conn.del(name)
conn.exists(key)
conn.expire(key, 60)
conn.type(key)


# hashes
conn.hgetall("#{key}:workers")
conn.hget(key, "busy")
conn.hmget(key, "info", "busy", "beat", "quiet")
conn.hmset(key, "info", to_json, "busy", curstate.size, "beat", Time.now.to_f, "quiet", @done)
conn.hset(workers_key, tid, Sidekiq.dump_json(hash))

# sets

conn.sadd("queues", queue)
conn.scard("processes")
conn.srem("queues", name)
conn.sscan(key, cursor)

# sorted sets

conn.zadd("schedule", ...)
conn.zcard("schedule")
conn.zrangebyscore("retry", score, score)
conn.zrange(key, starting, ending, with_scores: true)
conn.zrem(name, element)
conn.zremrangebyrank(name, 0, - self.class.max_jobs)
conn.zremrangebyscore(parent.name, score, score)
conn.zrem(sorted_set, job)
conn.zrevrange(key, starting, ending, with_scores: true)

# lists

conn.brpop(*queues_cmd)
conn.llen(key)
conn.lpush("queue:#{queue}", to_push)
conn.lrange(key, starting, ending)
conn.lrem("queue:#{@queue}", 1, @value)
conn.rpop("#{key}-signals")
conn.rpush("queue:#{queue_name}", job)


# server

conn.info

# transactions

conn.multi
